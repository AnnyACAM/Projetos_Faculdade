#ifndef ARVOREAVL_HPP#define ARVOREAVL_HPP
#include <iostream>#include "ListaEncadeada.hpp"#include "Evento.hpp"
template <typename TipoChave, typename TipoValor>class ArvoreAVL {private:    // O Nó da árvore é uma struct privada e genérica.    // Ninguém fora da classe precisa saber como ele é implementado.    struct Node {        TipoChave chave;        TipoValor valor;        Node* esquerda;        Node* direita;        int altura;    };
    Node* raiz; // A única variável membro que a árvore precisa
    // Funções para gerenciar a altura e o balanceamento    int getAltura(Node* no);    int getFatorBalanceamento(Node* no);    void atualizarAltura(Node* no);        // Funções de rotação para manter o balanceamento (que vamos implementar)    Node* rotacaoDireita(Node* y);    Node* rotacaoEsquerda(Node* x);    Node* rotacaoEsquerdaDireita(Node* z); // Rotação dupla esquerda-direita (caso LR)    Node* rotacaoDireitaEsquerda(Node* z); // Rotação dupla direita-esquerda (caso RL)        // Função recursiva principal para inserir um novo nó    Node* insereRecursivo(Node* no, TipoChave chave, TipoValor valor);
    // Função para encontrar o nó com o menor valor (usado na remoção)    Node* encontrarMinimo(Node* no);
    // Função recursiva principal para remover um nó    Node* removeRecursivo(Node* no, TipoChave chave);
    // Função recursiva para buscar um valor    TipoValor* buscaRecursiva(Node* no, TipoChave chave);
    // Função para limpar a árvore (usada pelo destrutor)    void limpaRecursivo(Node* no);    void getTodosOsValoresRecursivo(Node* no, ListaEncadeada<TipoValor>& lista);
public:    // Construtor: cria uma árvore vazia.    ArvoreAVL();    // Destrutor: libera toda a memória alocada pela árvore.    ~ArvoreAVL();
    // --- MÉTODOS PÚBLICOS PRINCIPAIS ---
    // Insere um par (chave, valor) na árvore.    void Insere(TipoChave chave, TipoValor valor);    // Remove um nó da árvore com base na chave.    void Remove(TipoChave chave);    // Busca um valor na árvore com base na chave. Retorna um ponteiro para o valor ou nullptr se não encontrar.    TipoValor* Busca(TipoChave chave);    // Verifica se a árvore está vazia.    bool Vazia() const;    //para facilitar o delete dos objetos armazenados na árvore    // Retorna uma lista com todos os valores (ponteiros) armazenados na árvore    //mandamos essa lista pro main, oq ual deletará os Pacotes/Clientes    void getTodosOsValores(ListaEncadeada<TipoValor>& lista);};

// ------------------- IMPLEMENTAÇÃO -------------------// Como é uma classe template, as implementações dos métodos virão aqui embaixo
//construtor da árvore AVL - inicializa a raiz como nula.template <typename TipoChave, typename TipoValor>ArvoreAVL<TipoChave, TipoValor>::ArvoreAVL() {    this->raiz = nullptr; }
//destrutor da árvore AVL - chama a função recursiva para limpar a árvore.template <typename TipoChave, typename TipoValor>ArvoreAVL<TipoChave, TipoValor>::~ArvoreAVL() {    limpaRecursivo(this->raiz);}
// retorna a altura de um nótemplate <typename TipoChave, typename TipoValor>int ArvoreAVL<TipoChave, TipoValor>::getAltura(Node* no) {    if (no == nullptr) {        return 0; // A altura de um nó nulo (espaço vazio) é 0.    }    return no->altura; // Retorna a altura que está armazenada no próprio nó.}
// calcula a "inclinação" da árvore a partir de um nó e retorna o fator de balanceamento.template <typename TipoChave, typename TipoValor>int ArvoreAVL<TipoChave, TipoValor>::getFatorBalanceamento(Node* no) {    if (no == nullptr) {        return 0;    }    // A função usa o getAltura que acabamos de criar para fazer o cálculo.    return getAltura(no->direita) - getAltura(no->esquerda);}
//recalcula e atualiza a altura de um nó com base na altura de seus filhos.template <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::atualizarAltura(Node* no) {    if (no != nullptr) {        // A altura de um nó é 1 + a altura do seu filho mais alto.        no->altura = 1 + std::max(getAltura(no->esquerda), getAltura(no->direita));    }}
// Realiza uma Rotação Simples à Direita para corrigir um desbalanceamento à esquerda.template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::rotacaoDireita(Node* y) {    Node* x = y->esquerda;    Node* T2 = x->direita;
    // Realiza a rotação    x->direita = y;    y->esquerda = T2;
    // Atualiza as alturas dos nós que mudaram de posição.    // A ordem é importante: primeiro o nó que "desceu" (y), depois o que "subiu" (x).    atualizarAltura(y);    atualizarAltura(x);
    // Retorna a nova raiz da sub-árvore    return x;}
// Realiza uma Rotação Simples à Direita para corrigir um desbalanceamento à esquerda.template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::rotacaoEsquerda(Node* x) {    Node* y = x->direita;    Node* T2 = y->esquerda;
    // Realiza a rotação    y->esquerda = x;    x->direita = T2;
    // Atualiza as alturas    atualizarAltura(x);    atualizarAltura(y);
    // Retorna a nova raiz da sub-árvore    return y;}
// Realiza uma Rotação Dupla Esquerda-Direita (caso LR).template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::rotacaoEsquerdaDireita(Node* z) {    // 1. Primeiro, faz uma rotação à ESQUERDA no filho esquerdo de z.    // Isso transforma o caso "zigue-zague" (LR) em um caso simples (LL).    z->esquerda = rotacaoEsquerda(z->esquerda);
    // 2. Agora, aplica a rotação simples à DIREITA em z para corrigir o caso LL.    return rotacaoDireita(z);}
// Realiza uma Rotação Dupla Direita-Esquerda (caso RL).template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::rotacaoDireitaEsquerda(Node* z) {    // 1. Primeiro, faz uma rotação à DIREITA no filho direito de z.    // Isso transforma o caso "zigue-zague" (RL) em um caso simples (RR).    z->direita = rotacaoDireita(z->direita);
    // 2. Agora, aplica a rotação simples à ESQUERDA em z para corrigir o caso RR.    return rotacaoEsquerda(z);}
//limpa de forma recursiva a árvore, deletando todos os nós e seus valores.template <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::limpaRecursivo(Node* no) {    if (no == nullptr) {        return; // Caso base da recursão    }        // Primeiro, limpa recursivamente os filhos    limpaRecursivo(no->esquerda);    limpaRecursivo(no->direita);    // DEPOIS de limpar os filhos, deleta o nó atual.    delete no;}
// insere um novo nó na árvore de forma recursiva, mantendo o balanceamento.template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::insereRecursivo(Node* no, TipoChave chave, TipoValor valor) {    // Passo 1: Inserção padrão de uma Árvore de Busca Binária    if (no == nullptr) {        Node* novoNode = new Node();        novoNode->chave = chave;        novoNode->valor = valor;        novoNode->esquerda = nullptr;        novoNode->direita = nullptr;        novoNode->altura = 1; // Nós novos são sempre folhas com altura 1        return novoNode;    }
    if (chave < no->chave) {        no->esquerda = insereRecursivo(no->esquerda, chave, valor);    } else if (chave > no->chave) {        no->direita = insereRecursivo(no->direita, chave, valor);    } else {        // Chaves duplicadas não são permitidas, simplesmente retorna o nó        return no;    }
    // Passo 2: Atualiza a altura do nó ancestral atual    atualizarAltura(no);
    // Passo 3: Calcula o fator de balanceamento deste nó para ver se ele ficou desbalanceado    int balance = getFatorBalanceamento(no);
    // Passo 4: Se o nó ficou desbalanceado, aplica uma das 4 rotações
    // Caso Esquerda-Esquerda (LL)    if (balance < -1 && chave < no->esquerda->chave) {        return rotacaoDireita(no);    }
    // Caso Direita-Direita (RR)    if (balance > 1 && chave > no->direita->chave) {        return rotacaoEsquerda(no);    }
    // Caso Esquerda-Direita (LR)    if (balance < -1 && chave > no->esquerda->chave) {        return rotacaoEsquerdaDireita(no);    }
    // Caso Direita-Esquerda (RL)    if (balance > 1 && chave < no->direita->chave) {        return rotacaoDireitaEsquerda(no);    }
    // Se não entrou em nenhum caso de desbalanceamento, retorna o nó sem alterações    return no;}
// Função recursiva para buscar um valor com base em uma chave.template <typename TipoChave, typename TipoValor>TipoValor* ArvoreAVL<TipoChave, TipoValor>::buscaRecursiva(Node* no, TipoChave chave) {    // Caso base 1: a chave não foi encontrada.    if (no == nullptr) {        return nullptr;    }
    // Compara a chave de busca com a chave do nó atual    if (chave < no->chave) {        // Se a chave for menor, busca na sub-árvore esquerda.        return buscaRecursiva(no->esquerda, chave);    } else if (chave > no->chave) {        // Se a chave for maior, busca na sub-árvore direita.        return buscaRecursiva(no->direita, chave);    } else {        // Caso base 2: a chave foi encontrada. Retorna um ponteiro para o valor.        return &(no->valor);    }}
// Função para encontrar o nó com a menor chave em uma sub-árvore (sempre o mais à esquerda).template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::encontrarMinimo(Node* no) {    Node* atual = no;    while (atual != nullptr && atual->esquerda != nullptr) {        atual = atual->esquerda;    }    return atual;}
// Função recursiva para remover um nó e rebalancear a árvore.template <typename TipoChave, typename TipoValor>typename ArvoreAVL<TipoChave, TipoValor>::Node* ArvoreAVL<TipoChave, TipoValor>::removeRecursivo(Node* no, TipoChave chave) {    // Passo 1: Remoção padrão de uma Árvore de Busca Binária    if (no == nullptr) {        return no; // Chave não encontrada    }    if (chave < no->chave) {        no->esquerda = removeRecursivo(no->esquerda, chave);    } else if (chave > no->chave) {        no->direita = removeRecursivo(no->direita, chave);    } else {        // Nó com a chave a ser removida foi encontrado        if (no->esquerda == nullptr || no->direita == nullptr) { // Caso com 0 ou 1 filho            Node* temp = no->esquerda ? no->esquerda : no->direita;            if (temp == nullptr) { // Sem filhos                temp = no;                no = nullptr;            } else { // Com 1 filho                *no = *temp; // Copia o conteúdo do filho para o nó atual            }            delete temp;        } else { // Caso com 2 filhos            Node* temp = encontrarMinimo(no->direita); // Encontra o sucessor in-order            no->chave = temp->chave; // Copia a chave do sucessor            no->valor = temp->valor; // Copia o valor do sucessor            no->direita = removeRecursivo(no->direita, temp->chave); // Deleta o sucessor        }    }    if (no == nullptr) {        return no; // Se a árvore ficou vazia    }    // Passos 2 e 3: Atualiza a altura e calcula o fator de balanceamento    atualizarAltura(no);    int balance = getFatorBalanceamento(no);    // Passo 4: Se o nó ficou desbalanceado, aplica uma das 4 rotações    // Caso Esquerda (desbalanceamento -2)    if (balance < -1) {        if (getFatorBalanceamento(no->esquerda) <= 0) { // Caso Esquerda-Esquerda (LL)            return rotacaoDireita(no);        } else { // Caso Esquerda-Direita (LR)            return rotacaoEsquerdaDireita(no);        }    }    // Caso Direita (desbalanceamento +2)    if (balance > 1) {        if (getFatorBalanceamento(no->direita) >= 0) { // Caso Direita-Direita (RR)            return rotacaoEsquerda(no);        } else { // Caso Direita-Esquerda (RL)            return rotacaoDireitaEsquerda(no);        }    }
    return no;}
// Verifica se a árvore está vazia.template <typename TipoChave, typename TipoValor>bool ArvoreAVL<TipoChave, TipoValor>::Vazia() const {    return this->raiz == nullptr;}
// Busca um valor na árvore com base na chave. Retorna um ponteiro para o valor ou nullptr se não encontrar.template <typename TipoChave, typename TipoValor>TipoValor* ArvoreAVL<TipoChave, TipoValor>::Busca(TipoChave chave) {    return buscaRecursiva(this->raiz, chave);}
// método superficial adicionar o nó na árvore.template <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::Insere(TipoChave chave, TipoValor valor) {    this->raiz = insereRecursivo(this->raiz, chave, valor);}
// Remove um nó da árvore com base na chave.template <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::Remove(TipoChave chave) {    // Ele simplesmente chama a função recursiva começando pela raiz    // e atualiza a raiz com o resultado (caso a raiz mude após uma rotação).    this->raiz = removeRecursivo(this->raiz, chave);}
// Método público que o main vai chamartemplate <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::getTodosOsValores(ListaEncadeada<TipoValor>& lista) {    getTodosOsValoresRecursivo(this->raiz, lista);}
// Método privado que faz o trabalho pesado (percurso in-order)template <typename TipoChave, typename TipoValor>void ArvoreAVL<TipoChave, TipoValor>::getTodosOsValoresRecursivo(Node* no, ListaEncadeada<TipoValor>& lista) {    if (no == nullptr) {        return; // Condição de parada da recursão    }        // Visita a sub-árvore esquerda    getTodosOsValoresRecursivo(no->esquerda, lista);    // Adiciona o valor do nó atual à lista    lista.InsereFinal(no->valor);    // Visita a sub-árvore direita    getTodosOsValoresRecursivo(no->direita, lista);}
#endif // ARVOREAVL_HPP